{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n};\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`');\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, types.whitespace)(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === codes.dollarSign) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, types.linePrefix, initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, types.linePrefix, constants.tabSize);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === codes.dollarSign) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, types.whitespace)(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","codes","constants","types","mathFlow","tokenize","tokenizeMathFenced","concrete","nonLazyContinuation","tokenizeNonLazyContinuation","partial","effects","nok","self","tail","events","length","initialSize","type","linePrefix","sliceSerialize","sizeOpen","start","code","dollarSign","enter","sequenceOpen","consume","exit","metaBefore","whitespace","eof","metaAfter","chunkString","contentType","contentTypeString","meta","interrupt","attempt","beforeNonLazyContinuation","after","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","size","beforeSequenceClose","tabSize","sequenceClose","afterSequenceClose","lineEnding","lineStart","parser","lazy","now","line"],"sources":["E:/CScourse/视听觉/Sound-Quality-HCI/node_modules/micromark-extension-math/dev/lib/math-flow.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`')\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, types.whitespace)(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n\n    effects.enter('mathFlowFenceMeta')\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n\n    if (code === codes.dollarSign) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n\n    if (self.interrupt) {\n      return ok(code)\n    }\n\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {tokenize: tokenizeClosingFence, partial: true},\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            types.linePrefix,\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      types.linePrefix,\n      constants.tabSize\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === codes.dollarSign) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, types.whitespace)(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}